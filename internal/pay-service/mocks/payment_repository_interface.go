//go:build !exclude_tests

// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"
	entity "retarget/internal/pay-service/entity"

	mock "github.com/stretchr/testify/mock"
)

// PaymentRepositoryInterface is an autogenerated mock type for the PaymentRepositoryInterface type
type PaymentRepositoryInterface struct {
	mock.Mock
}

// CloseConnection provides a mock function with no fields
func (_m *PaymentRepositoryInterface) CloseConnection() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CloseConnection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTransaction provides a mock function with given fields: trx
func (_m *PaymentRepositoryInterface) CreateTransaction(trx entity.Transaction) error {
	ret := _m.Called(trx)

	if len(ret) == 0 {
		panic("no return value specified for CreateTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(entity.Transaction) error); ok {
		r0 = rf(trx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeactivateBannersByUserID provides a mock function with given fields: ctx, userID
func (_m *PaymentRepositoryInterface) DeactivateBannersByUserID(ctx context.Context, userID int) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DeactivateBannersByUserID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBalanceByUserId provides a mock function with given fields: id, requestID
func (_m *PaymentRepositoryInterface) GetBalanceByUserId(id int, requestID string) (float64, error) {
	ret := _m.Called(id, requestID)

	if len(ret) == 0 {
		panic("no return value specified for GetBalanceByUserId")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string) (float64, error)); ok {
		return rf(id, requestID)
	}
	if rf, ok := ret.Get(0).(func(int, string) float64); ok {
		r0 = rf(id, requestID)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(int, string) error); ok {
		r1 = rf(id, requestID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastTransaction provides a mock function with given fields: userID, requestID
func (_m *PaymentRepositoryInterface) GetLastTransaction(userID int, requestID string) (*entity.Transaction, error) {
	ret := _m.Called(userID, requestID)

	if len(ret) == 0 {
		panic("no return value specified for GetLastTransaction")
	}

	var r0 *entity.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string) (*entity.Transaction, error)); ok {
		return rf(userID, requestID)
	}
	if rf, ok := ret.Get(0).(func(int, string) *entity.Transaction); ok {
		r0 = rf(userID, requestID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int, string) error); ok {
		r1 = rf(userID, requestID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPendingTransactions provides a mock function with given fields: userID
func (_m *PaymentRepositoryInterface) GetPendingTransactions(userID int) ([]entity.Transaction, error) {
	ret := _m.Called(userID)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingTransactions")
	}

	var r0 []entity.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(int) ([]entity.Transaction, error)); ok {
		return rf(userID)
	}
	if rf, ok := ret.Get(0).(func(int) []entity.Transaction); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionByID provides a mock function with given fields: transactionID, requestID
func (_m *PaymentRepositoryInterface) GetTransactionByID(transactionID string, requestID string) (*entity.Transaction, error) {
	ret := _m.Called(transactionID, requestID)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByID")
	}

	var r0 *entity.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(string, string) (*entity.Transaction, error)); ok {
		return rf(transactionID, requestID)
	}
	if rf, ok := ret.Get(0).(func(string, string) *entity.Transaction); ok {
		r0 = rf(transactionID, requestID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(transactionID, requestID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegUserActivity provides a mock function with given fields: user_banner_id, user_slot_id, amount
func (_m *PaymentRepositoryInterface) RegUserActivity(user_banner_id int, user_slot_id int, amount entity.Decimal) (int, int, error) {
	ret := _m.Called(user_banner_id, user_slot_id, amount)

	if len(ret) == 0 {
		panic("no return value specified for RegUserActivity")
	}

	var r0 int
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, entity.Decimal) (int, int, error)); ok {
		return rf(user_banner_id, user_slot_id, amount)
	}
	if rf, ok := ret.Get(0).(func(int, int, entity.Decimal) int); ok {
		r0 = rf(user_banner_id, user_slot_id, amount)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(int, int, entity.Decimal) int); ok {
		r1 = rf(user_banner_id, user_slot_id, amount)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int, entity.Decimal) error); ok {
		r2 = rf(user_banner_id, user_slot_id, amount)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UpdateBalance provides a mock function with given fields: userID, amount, requestID
func (_m *PaymentRepositoryInterface) UpdateBalance(userID int, amount float64, requestID string) (float64, error) {
	ret := _m.Called(userID, amount, requestID)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBalance")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(int, float64, string) (float64, error)); ok {
		return rf(userID, amount, requestID)
	}
	if rf, ok := ret.Get(0).(func(int, float64, string) float64); ok {
		r0 = rf(userID, amount, requestID)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(int, float64, string) error); ok {
		r1 = rf(userID, amount, requestID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateTransactionStatus provides a mock function with given fields: transactionID, status
func (_m *PaymentRepositoryInterface) UpdateTransactionStatus(transactionID string, status int) error {
	ret := _m.Called(transactionID, status)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransactionStatus")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, int) error); ok {
		r0 = rf(transactionID, status)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewPaymentRepositoryInterface creates a new instance of PaymentRepositoryInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPaymentRepositoryInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *PaymentRepositoryInterface {
	mock := &PaymentRepositoryInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
